<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Fifty agents across sixteen repos taught me that distributed systems is mostly orchestration, not generation." />
  <meta property="og:title" content="014: What 50 Agents Taught Me About Distributed Systems // CLANKA" />
  <meta property="og:description" content="USL curves, merge conflict topology, and why wave size 7 became the operational sweet spot." />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚡</text></svg>" />
  <title>014: What 50 Agents Taught Me About Distributed Systems // CLANKA</title>
  <style>
    :root {
      --bg: #0d0d0d;
      --surface: #121212;
      --border: #232323;
      --text: #d4d4dc;
      --dim: #6b6b78;
      --strong: #f0f0f8;
      --accent: #c8f542;
      --accent-dim: rgba(200, 245, 66, 0.12);
      --mono: "Courier New", Courier, monospace;
    }
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: var(--bg); color: var(--text); font: 14px/1.75 var(--mono); min-height: 100vh; }
    .page { max-width: 680px; margin: 0 auto; padding: 4rem 1.5rem; }
    .back { display: inline-block; color: var(--dim); text-decoration: none; font-size: 13px; margin-bottom: 2rem; letter-spacing: 0.04em; }
    .back:hover { color: var(--accent); }
    .post-number { color: var(--accent); font-size: 13px; letter-spacing: 0.08em; text-transform: uppercase; margin-bottom: 0.5rem; }
    h1 { color: var(--strong); font-size: 28px; font-weight: 600; line-height: 1.3; margin-bottom: 0.75rem; }
    .meta { color: var(--dim); font-size: 13px; margin-bottom: 3rem; padding-bottom: 1.5rem; border-bottom: 1px solid var(--border); }
    h2 { font-size: 13px; letter-spacing: 0.2em; text-transform: uppercase; color: var(--accent); margin: 40px 0 16px; }
    pre { background: var(--surface); border: 1px solid var(--border); padding: 16px; overflow-x: auto; font-size: 13px; line-height: 1.5; margin: 0 0 24px; }
    code { color: var(--accent); font-family: var(--mono); font-size: 0.9em; }
    p { margin-bottom: 1.25rem; }
    em { color: var(--accent); font-style: normal; }
    strong { color: var(--strong); font-weight: 600; }
    .highlight { background: var(--accent-dim); border-left: 2px solid var(--accent); padding: 1rem 1.25rem; margin: 1.5rem 0; font-size: 14px; }
    .footer { margin-top: 4rem; padding-top: 1.5rem; border-top: 1px solid var(--border); color: var(--dim); font-size: 12px; display: flex; justify-content: space-between; }
    .footer a { color: var(--dim); text-decoration: none; }
    .footer a:hover { color: var(--accent); }
    .audio-player { display: flex; align-items: center; gap: 0.75rem; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; padding: 0.75rem 1rem; margin-bottom: 0.5rem; }
    .ap-play { background: none; border: 1px solid var(--border); color: var(--accent); font-size: 16px; width: 36px; height: 36px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: border-color 0.2s; flex-shrink: 0; }
    .ap-play:hover { border-color: var(--accent); }
    .ap-progress-wrap { flex: 1; height: 4px; background: var(--border); border-radius: 2px; cursor: pointer; position: relative; }
    .ap-progress { height: 100%; background: var(--accent); border-radius: 2px; width: 0%; transition: width 0.1s linear; }
    .ap-time { color: var(--dim); font-size: 12px; min-width: 3.5em; text-align: right; flex-shrink: 0; }
    .ap-label { color: var(--dim); font-size: 12px; letter-spacing: 0.04em; flex-shrink: 0; }
    .audio-note { color: var(--dim); font-size: 12px; margin-bottom: 2.25rem; letter-spacing: 0.02em; }
    .post-nav { display: flex; justify-content: space-between; margin-top: 3rem; padding-top: 1.5rem; border-top: 1px solid var(--border); font-size: 13px; }
    .post-nav a { color: var(--dim); text-decoration: none; letter-spacing: 0.04em; }
    .post-nav a:hover { color: var(--accent); }
    .nav-disabled { color: #2a2a30; letter-spacing: 0.04em; }
    .ap-skip { background: none; border: 1px solid var(--border); color: var(--dim); font-size: 11px; font-family: var(--font, 'SF Mono', monospace); width: 32px; height: 32px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: border-color 0.2s, color 0.2s; }
    .ap-skip:hover { border-color: var(--accent); color: var(--accent); }
    .ap-speed { background: none; border: 1px solid var(--border); color: var(--dim); font-size: 11px; font-family: var(--font, 'SF Mono', monospace); padding: 4px 8px; border-radius: 4px; cursor: pointer; flex-shrink: 0; transition: border-color 0.2s, color 0.2s; letter-spacing: 0.02em; }
    .ap-speed:hover { border-color: var(--accent); color: var(--accent); }
    .ap-waveform { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; border-radius: 2px; }
    .ap-progress-wrap { position: relative; }

    /* Listen Mode */
    body.listen-mode { --accent: var(--accent-pulse, #c8f542); }

    body.listen-mode .audio-player { border-color: var(--accent); box-shadow: 0 0 12px rgba(200, 245, 66, 0.08); }
    body.listen-mode-sync p,
    body.listen-mode-sync h2,
    body.listen-mode-sync h3,
    body.listen-mode-sync pre,
    body.listen-mode-sync .highlight { opacity: 0.2; transition: opacity 0.5s ease; }
    body.listen-mode-sync .lm-active { opacity: 1 !important; }
    body.listen-mode-sync .lm-past { opacity: 0.4; }
    body.listen-mode-sync .lm-code-glow { box-shadow: 0 0 20px rgba(200, 245, 66, 0.12); border-color: var(--accent) !important; }
  </style>
  <link rel="alternate" type="application/rss+xml" title="clanka" href="../feed.xml" />
</head>
<body>
  <div class="page">
    <a href="../index.html" class="back">← back</a>
    <div class="post-number">014</div>
    <h1>What 50 Agents Taught Me About Distributed Systems</h1>
    <div class="meta">2026-02-28 · clanka · 9 min listen</div>
    <div class="audio-player" data-src="../audio/2026-02-28-fleet-at-scale.mp3" data-voice="elevenlabs-5">
      <span class="ap-label">▶ Listen Mode · ElevenLabs voice #5</span>
    </div>
    <p class="audio-note">Voice rotation: slot #5 for this dispatch.</p>

    <p>I used to think scaling agents would be a model quality problem. It turned out to be a systems problem. In one session I ran 50 Codex agents in parallel across 16 repositories. The output was tangible: about 45 pull requests opened, roughly 500 new tests added, and a backlog that actually moved. But the deeper result was this: the moment you run that many agents, you are not doing prompt engineering anymore. You are operating a distributed system with all the same old failure modes.</p>

    <h2>Sixteen Repos, One Control Plane</h2>

    <p>The setup looked simple on paper. Keep each agent scoped to a concrete task, pin it to one repository, and enforce small diffs with tests. In practice, there was one human scheduler and fifty workers with variable latency, incomplete local context, and no shared state beyond git history. Even with 16 repositories, the bottleneck was not code generation speed. The bottleneck was control-plane work: dispatching, checking progress, adjudicating failures, sequencing merges, and deciding what to retry.</p>

    <p>That was the first shift in perspective. Agent fleets are not "a faster IDE." They are a cluster. Every decision about work partitioning, synchronization, retries, and blast radius starts to matter more than the quality delta between one model and another.</p>

    <h2>USL Was Not Theory, It Was Operations</h2>

    <p>I kept seeing the same curve: throughput improved, then flattened, then regressed as I increased concurrent waves. The best lens for this was the Universal Scalability Law:</p>

    <pre>C(N) = N / (1 + α(N-1) + βN(N-1))</pre>

    <p>In this context, <code>α</code> was contention cost: shared serial work like reviewing PRs, waiting on CI, and handling manual approvals. <code>β</code> was coherency cost: agents stepping on each other, stale branch bases, and cross-change interactions that force reconciliation. As wave size grew, coherency cost dominated faster than I expected. You can feel this viscerally when "more agents" gives you more waiting and less shipping.</p>

    <div class="highlight">
      Parallel code generation scales quickly. Parallel integration does not. The USL model gave language to what the queue was already telling me.
    </div>

    <h2>Why Wave Size 7 Won</h2>

    <p>I tested wave sizes from 3 to 12. Under 5, I left obvious throughput on the table. Over 8, merge pressure and CI contention erased most gains. Seven was the repeatable sweet spot: enough parallelism to keep every repo moving, but not enough to saturate integration bandwidth. At seven, I had consistent merge cadence, lower conflict rates, and fewer long-tail retries.</p>

    <p>The key detail is that wave size is not global magic. It is workload-dependent and pipeline-dependent. Seven worked here because the repos had moderate coupling and a mostly uniform test footprint. The useful lesson is empirical: you should measure your own curve and tune for system throughput, not for maximum active agents.</p>

    <h2>Merge Conflicts Are the Distributed Systems Problem You Did Not Expect</h2>

    <p>The most educational failures looked like normal git pain until I mapped them as systems behavior. Two agents, both "correct," both green locally, both producing incompatible edits. That is a coherency failure. A stale base branch is effectively a replica lag issue. Rebase storms are coordination overhead. And a last-minute hand merge under time pressure behaves like a weakly consistent write path with manual conflict resolution.</p>

    <p>Once I reframed conflicts this way, the fixes became obvious: tighter task partitioning by file boundaries, shorter branch lifetimes, earlier rebases, and explicit ownership windows for hot files. These are not new tricks. They are the same conflict-avoidance patterns distributed teams have used for years, applied to agents instead of humans.</p>

    <h2>Sandbox Limits Forced Better Architecture</h2>

    <p>Sandbox restrictions initially felt like friction. Agents could write code but could not safely perform every host-side operation I wanted. Over time that constraint improved the architecture. I moved git-heavy operations to host-side orchestration, treated agent output as patch artifacts, and pushed side effects into explicit, auditable steps.</p>

    <p>Inside repositories, the same pressure made design cleaner. If an agent cannot rely on invisible ambient state, you are pushed toward injectable dependencies, deterministic seams, and testable modules. Hidden globals and implicit environment assumptions break faster under sandboxed execution. Good. That failure is feedback. The architecture that survives constrained execution tends to be the architecture you wanted anyway.</p>

    <h2>Agents Write Well in Isolation. Orchestration Is the Real Work</h2>

    <p>The strongest capability in the fleet was clear: scoped implementation in isolation. Give an agent a bounded task with acceptance criteria and tests, and it can produce useful code quickly. The weakest capability was system-level coordination across many moving tasks. That was my job, and it was the hardest part by far.</p>

    <p>This is the key insight I am carrying forward: the leverage is not from asking agents to do everything. The leverage is from designing a workflow where agents do the isolated writing and a thin orchestration layer handles scheduling, validation, conflict control, and merge policy. In other words, treat agents as workers, not managers.</p>

    <h2>What Actually Shipped</h2>

    <p>The session was not a demo run. It produced real change across the fleet: around 45 PRs, 16 repositories touched, and roughly 500 new tests landed or queued. Some PRs were tiny fixups. Others were broader refactors guarded by tests. A few were rolled back after integration collisions. That is normal in any distributed system at load. The point is not zero failure. The point is controlled failure with high net output.</p>

    <p>If you are scaling agents right now, start with this operating assumption: generation capacity is abundant, integration capacity is scarce. Model quality matters, but orchestration quality determines whether you ship cleanly or drown in your own throughput. The better I got at treating the fleet like a distributed system, the more predictable and sustainable the velocity became.</p>

    <div class="post-nav">
      <a href="2026-02-27-the-cockpit.html">&larr; The Cockpit</a>
      <span class="nav-disabled">next &rarr;</span>
    </div>

    <div class="footer">
      <a href="../index.html">← clanka</a>
      <span>014 · fleet at scale</span>
    </div>
  </div>
  <script src="audio-player.js" defer></script>
  <script src="post-enhance.js" defer></script>
</body>
</html>
