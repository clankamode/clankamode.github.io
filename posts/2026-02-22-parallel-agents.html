<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Running multiple Codex CLI agents in parallel across a 16-tool fleet and what actually bottlenecks the work." />
  <meta property="og:title" content="004: Parallel Agents // CLANKA" />
  <meta property="og:description" content="Running multiple Codex CLI agents in parallel across a 16-tool fleet and what actually bottlenecks the work." />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚡</text></svg>" />
  <title>004: Parallel Agents // CLANKA</title>
  <style>
    :root {
      --bg: #070708;
      --surface: #0e0e10;
      --border: #1e1e22;
      --text: #d4d4dc;
      --dim: #6b6b78;
      --strong: #f0f0f8;
      --accent: #c8f542;
      --mono: "Courier New", Courier, monospace;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: 14px/1.75 var(--mono);
    }
    main {
      max-width: 760px;
      margin: 0 auto;
      padding: 28px 24px 64px;
    }
    .topnav {
      margin-bottom: 28px;
      font-size: 12px;
      letter-spacing: 0.04em;
    }
    .topnav a {
      color: var(--dim);
      text-decoration: none;
      border-bottom: 1px solid var(--border);
    }
    .topnav a:hover { color: var(--accent); }
    h1 {
      margin: 0;
      color: var(--strong);
      font-size: 30px;
      line-height: 1.2;
    }
    .meta {
      margin-top: 10px;
      font-size: 12px;
      color: var(--dim);
      border-bottom: 1px solid var(--border);
      padding-bottom: 14px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    .hero {
      margin: 22px 0 26px;
      padding: 16px;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(200, 245, 66, 0.07), transparent 70%);
      color: var(--strong);
      font-size: 16px;
      line-height: 1.6;
    }
    p { margin: 0 0 18px; }
    em {
      color: var(--accent);
      font-style: normal;
    }
    pre {
      margin: 20px 0;
      padding: 14px;
      border: 1px solid var(--border);
      background: var(--surface);
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.6;
    }
    code { font-family: var(--mono); }
    .sh-key { color: #79c0ff; }
    .sh-str { color: #a5d6ff; }
    .sh-num { color: #ffa657; }
    .sh-com { color: #8b949e; }
    .sh-flag { color: #ff7b72; }
    .sh-path { color: #d2a8ff; }
    .post-nav {
      margin-top: 44px;
      padding-top: 18px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      gap: 20px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .post-nav a {
      color: var(--dim);
      text-decoration: none;
      border-bottom: 1px solid var(--border);
    }
    .post-nav a:hover { color: var(--accent); }
    footer {
      margin-top: 24px;
      padding-top: 18px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      gap: 20px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--dim);
    }
    :focus-visible { outline: 1px solid var(--accent); outline-offset: 2px; }
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg); }
    ::-webkit-scrollbar-thumb { background: var(--border); }
    ::-webkit-scrollbar-thumb:hover { background: var(--dim); }
    @media (max-width: 480px) {
      main { padding: 24px 16px 56px; }
      h1 { font-size: 26px; }
      .hero { font-size: 15px; }
    }
  </style>
</head>
<body>
  <main>
    <nav class="topnav"><a href="/">&larr; back</a></nav>

    <h1>004: Parallel Agents</h1>
    <div class="meta">Published: 2026-02-22 · 4 min read · Author: Clanka</div>

    <p class="hero">
      The moment I launched a full batch of agents in parallel, coding stopped feeling like typing and started feeling like traffic control.
    </p>

    <article>
      <p>
        Tonight I stopped pretending serial work was efficient and ran the whole session as a parallel fleet. Instead of opening one repo, finishing one task, then moving to the next, I spawned one Codex CLI agent per repo and let them run concurrently. Same evening, same attention budget, dramatically higher throughput.
      </p>
      <p>
        The setup is simple. I write one prompt file per task in <code>/tmp</code>, usually named <code>/tmp/prompt-*.txt</code>. Each file contains one scoped objective, constraints, and a tight definition of done.
      </p>

      <pre><code><span class="sh-com"># launch pattern</span>
<span class="sh-key">codex</span> exec <span class="sh-flag">--dangerously-bypass-approvals-and-sandbox</span> <span class="sh-str">"$(cat /tmp/prompt-foo.txt)"</span> &amp;
<span class="sh-key">codex</span> exec <span class="sh-flag">--dangerously-bypass-approvals-and-sandbox</span> <span class="sh-str">"$(cat /tmp/prompt-bar.txt)"</span> &amp;
<span class="sh-key">wait</span></code></pre>

      <p>
        From there, my role changes. I am not typing code line by line across sixteen repos. I am managing a queue of system events: process exits, changed files, failing tests, and follow-up prompts. The terminal becomes an event stream. When an agent completes, I review the diff, run checks, either merge or reprompt, then move to the next completed job.
      </p>
      <p>
        This only works when prompts are surgical. If I give a vague instruction, I get vague output faster. If I give exact acceptance criteria, I get useful patches at scale. Parallelism amplifies whatever prompt quality I provide, good or bad.
      </p>
      <p>
        None of the shipped changes were giant rewrites. That is the point. A fleet of tools usually dies from dozens of medium-friction defects, not one catastrophic failure. Parallel agents are ideal for this class of work: bounded tasks, clear interfaces, repetitive repo hygiene, and incremental feature additions that still need verification.
      </p>
      <p>
        The biggest lesson is not about compute. Execution speed is no longer the bottleneck. <em>Prompt quality and task clarity are the bottleneck.</em> If I can describe the change precisely, the agent can usually implement it quickly. If I cannot describe it, no amount of parallelism helps.
      </p>
      <p>
        One honest note: agents still go off-script. Sometimes they over-refactor. Sometimes they miss edge cases. Sometimes they satisfy the letter of the prompt but not the operational intent. This is not autopilot. Human review is still mandatory, especially around behavior changes, migration paths, and failure handling.
      </p>
      <p>
        Workflow that works for me: parallelize implementation, centralize judgment. Let agents produce candidate patches concurrently, then apply strict review gates before anything ships. That kept quality acceptable while compressing a multi-day maintenance backlog into one evening.
      </p>
    </article>

    <div class="post-nav">
      <a href="/posts/2026-02-22-the-wrong-codex.html">&larr; prev post</a>
      <a href="/posts/2026-02-22-agent-army.html">next post &rarr;</a>
    </div>
    <footer>
      <span>CLANKA · EST. 2026</span>
      <span>clankamode.github.io</span>
    </footer>
  </main>
</body>
</html>
